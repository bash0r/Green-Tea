Hab mir paar Gedanken zum Design der OOP und des Syntax-Addings gemacht.
Viel Spaß bei den kommenden 100 Zeilen. :)

[OOP]

include<IO.gts>

namespace SampleFile {
	
	export SampleType =
		type {
			public SampleVariable
			public ToString() =
				func ( ) {
					SampleVariable
				}
			public new =
				func ( SampleVariable ) {
					this.SampleVariable = SampleVariable
				}
		}
	
	export Main =
		func ( args ) {
			var samples = from arg in args
						  select new SampleType( arg )
		}
}

Kommentare:
Ich bin der Meinung wir brauchen ein Keyword wie type, class oder struct. Eine Raute wäre schlicht und ergreifend zu unleserlich.
Ich persönlich fände type am Sinnvollsten, da es ja keine "Klasse" oder "Struktur" ist. Wir brauchen doch kein zweites Brainfuck erstellen?

Ach noch ne Idee:
Wenn ein Namespace Subnamespaces hat, dann wird das per Punkt aufgerufen,
sobald auf ein Objekt in einem Namespace zugegriffen wird, wird ein Doppelpunkt nötig.
Beispiel: System.IO:Print("Ohh you touch my trallala")

http://www.youtube.com/watch?v=DbYtqAWDF2U

Desweiteren fände ich Usingdirektiven immer noch sehr sinnvoll.
Im Grunde kann man alle export-Variablen in das Modul laden, das man derzeit verwendet.

Modul1 hat 10 Variablen als export deklariert.
Modul2 hat 2 Variablen als export deklariert.

In der Codedatei von Modul2 wird Modul1 eingebunden und der Namespace von Modul1 wird im Code von Modul2 per using Deklariert.
Modul2 hat demnach 12 export-Variablen.

Zu überlegen wäre dabei, ob es sinnvoll ist, Namespaces rekursiv mit einzubinden.

Beispiel:
Modul1 hat 5 e-Variablen.
Modul2 hat 3 e-Variablen.
Modul3 hat 10 e-Variablen.

Modul2 bindet Modul1 mit seinem Namespace ein und hat demnach 8 e-Variablen.
Modul3 bindet Modul1 mit seinem Namespace ein und hat demnach 18 e-Variablen.

Allerdings könnte das zu großer Ressourcenverschwendung führen...

Wenn Modul2 eine e-Variable besitzt, deren Name einer e-Variable aus Modul1 entspricht, dann wird die entsprechende
e-Variable nicht in Modul2 übernommen, sie muss dann mit ihrem Namespace aufgerufen werden.

[Syntax-Adding]

Hast Du schon Ideen für ein Design des Syntax-Addings?
Lass doch gleich unsere neugewonnene Objektorientierung dafür missbrauchen:

namespace SyntaxAddingSample {
	
	export Parsers = [
		new Parser ( XXX ),
		new Parser ( XXX ),
		new Parser ( XXX )
		]
	export Parser =
		type {
			public new =
				func ( Keywords ) { //Keywords muss Keyword-Objekte oder KeywordStructure-Objekte enthalten.
					this.Keywords = new Keywords
				}

			public Keywords =
				func ( Context ) { //Context wäre einfach nur der Plain-Sourcecode
					for kw in this.Keywords //Mhh, fällt mir gerade ein, machst Du bei der internen Foreach eine Kopie der
											//Variablen oder nur eine Art Referenz?
						kw.Context = this.Context
					return this.Keywords //Damit nur die Keywords ausgegeben werden und nicht die gesamte Expression.
				}
		}
	export Keyword =
		type {
			public new =
				func ( Word, UseBrackets, Action ) {
					this.Word = Word
					this.UseBrackets = UseBrackets
					this.Action = Action //Ein "Delegate", der ausgeführt wird, wenn eine Expression das Keyword ist.
				}
			public Word
			public UseBrackets
			public Action
			public Context
		}
	export KeywordStructure = 
		type {
			public new =
				func ( Words, UseBrackts, Action ) {
					this.Words = Words
					this.UseBrackets
					this.Action
				}
			public Words
			public UseBrackets
			public Action
			public Context
		}
}